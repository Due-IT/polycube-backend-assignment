# 🚀 실무적 관점의 객체지향 설계: 할인 정책 시스템 구현
    
이번 과제의 핵심 목표는 **변화에 유연한 실무형 아키텍처**를 구축하는 것이었습니다. 특히 비즈니스 요구사항에 따라 수시로 변하는 할인 정책을 안정적으로 수용하기 위해 다음과 같은 설계 원칙을 고민하고 적용했습니다.

<br>
<br>

# 기본 요구사항 🎯
과제의 기본 요구사항을 만족하는 과정에서 깊게 고민했던 과정을 담았습니다. 직관적이고 단순한 설계와 유연한 설계의 차이를 고민하면서 '왜 그렇게 했는가?'에 대한 근거를 명확히 설명하고자 하였습니다.

<br>

## DDD를 통한 응집도 향상
    
객체가 스스로 상태를 관리하고 로직을 수행하는 풍부한 도메인 모델을 지향했습니다. 특히 할인 정책 적용 로직을 서비스 계층에서 엔티티 내부로 응집시키는 과정에서 다음과 같은 설계적 고민을 거쳤습니다.
  
### 1. 풍부한 도메인 모델 지향
    
**고민 지점**   
기존 서비스 계층(OrderService)이 할인 금액을 직접 계산하고 이를 주문 객체(Order)에 주입하는 방식은 서비스 계층을 비대하게 만들고, 객체는 단순히 데이터를 담는 용도로 사용되었습니다.

    
**객체지향적 판단**   
서비스 계층은 비즈니스 흐름을 제어하는 **'조율자'** 역할에 집중해야 합니다. 구체적인 할인 계산과 적용은 주문 객체의 책임이라 판단하여 해당 로직을 `Order` 엔티티 내부로 위임했습니다.

    
**변경 내용**   
OrderService는 다음과 같은 전체 흐름을 관리하며, 세부적인 행동은 객체에게 위임함으로써 **'Tell, Don't Ask'** 의 능동적 구조를 설계하였습니다.

```
AS-IS (절차지향): 회원 찾기 -> 정책 찾기 -> 등급 꺼내기 -> 가격 꺼내기 -> 할인 금액 계산하기 -> 주문에 넣기 -> 결제하기   
    
TO-BE (객체지향): 회원 찾기 -> 정책 찾기 -> 주문에 할인 정책 적용하기 -> 결제하기
```
    
이로 인해 OrderService는 전체 비즈니스 프로세스를 보다 간결하고 직관적으로 관리할 수 있게 되었습니다.

<br>
    
### 2. DIP를 통한 결합도 제어

**고민 지점**   
주문(Order)가 할인정책(Policy)을 알게 되면서 의존성 문제가 발생하진 않을까 우려했습니다.
    
**객체지향적 판단**   
객체 간의 상호작용 시 의존에 의해 문제가 되는 상황은 대개 A가 바뀌면 B도 같이 고쳐야 할 때라고 생각합니다. 이를 구체 클래스가 아닌 인터페이스에 의존(DIP)하도록 설계하여 결합도를 제어하고자 하였습니다.

**변경 내용**
```
AS-IS (강한 결합): Order가 VIPDiscountPolicy 등의 구체 클래스를 직접 의존. 정책이 변경되거나 추가될 때마다 Order 내부 코드 수정이 불가피함.

TO-BE (약한 결합): Order는 DiscountPolicy 인터페이스만 의존. 실제 어떤 정책이 들어오는지와 무관하게 Order는 일관된 행위를 수행하며, 정책 확장에 자유로움.
```

<br>
<br>

# 전략 패턴 적용과 OCP 실현

다양한 할인 정책을 동적으로 선택할 수 있는 구조를 확립했습니다.

**고민 지점**   
직관적인 `if-else` 또는 `switch` 문 대신 리스트 순환 구조의 `전략 패턴`을 선택한 할인정책 적용 방식을 통해 얻는 실익이 무엇인가 고민했습니다.

**객체지향적 판단**   
조건문은 새로운 정책이 추가될 때마다 기존 코드를 수정해야 하는 **OCP 위반**을 야기합니다. 대신, `DiscountPolicyProvider`가 정책 리스트를 순회하며 지원 여부(`isSupport`)를 묻고 반환하는 방식은 Provider가 정책확장의 영향을 받지 않습니다.

**변경 내용**
```
AS-IS (OCP 위반): 정책 추가 시 관리 클래스(`Provider`)를 열어 분기문을 추가해야 함. 사이드 이펙트 위험 존재.

TO-BE (OCP 실현): 새로운 정책 클래스를 '추가'하기만 하면, 기존 로직의 수정 없이 즉시 시스템에 반영되는 **플러그인 구조**를 완성함.
```

<br>
<br>
    
# TDD를 통한 안정적인 확장

설계 방법론으로 단순한 사후 검증이 아닌 TDD를 활용했습니다.

**설계 의도**   
테스트를 단순한 사후 검증이 아닌 설계 가이드로 활용했습니다. 구현보다 객체에 기대하는 행위를 먼저 정의하여, 객체가 비대해지는 것을 방지하고 최소한의 책임만 지도록 유도했습니다.

**구현 방식**   
서비스를 먼저 만들고 테스트를 맞추는 것이 아니라, 원하는 입력과 결과를 먼저 명세화한 뒤 이를 충족하는 최소한의 코드를 구현했습니다.

**성과**   
핵심 도메인의 로직을 사전에 완벽히 검증함으로써 안정적인 확장이 가능해졌으며, 테스트 코드 자체가 시스템의 명세서가 되어 리팩토링 시 안정성을 확보할 수 있었습니다.

<br>
<br>

# 예외처리

**VVIP 혜택 역전 방지**   
정률 할인(10%) 적용 시, 저가 상품에서 VVIP가 VIP(고정 1,000원 할인)보다 적은 혜택을 받는 '역전 현상'을 방지하도록 구현하였습니다.

**마이너스 결제 차단**   
고정 할인액이 상품 가격보다 클 경우 발생할 수 있는 '마이너스 결제' 혹은 '결제 금액 0원 미만' 오류를 방지하고자 할인액이 원가를 초과하지 않도록 방어적으로 설계하여 비즈니스 무결성을 확보했습니다.

**결제 이력 무결성 확보**   
고객의 등급은 언제든 변할 수 있으므로, 추후 정산이나 CS 발생 시 결제 시점의 등급을 정확히 파악할 수 있도록 `Payment` 엔티티에 결제 당시의 `Grade`를 별도 필드로 저장하여, 데이터의 이력과 무결성을 확보했습니다.

<br>
<br>

# 추가적인 고려사항

- JPA의 `default_batch_fetch_size` 설정을 적용해 N+1 문제를 방지했습니다.
- DTO 성격의 객체는 record 타입을 사용해 보일러플레이트를 줄이고 불변성을 보장했습니다.
- 컨트롤러 버전관리 전략(/api/v1/…)을 통해 실무적 관점에서 서비스 운영의 안정성을 고려했습니다.
