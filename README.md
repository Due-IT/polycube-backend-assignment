# 실무적 관점의 객체지향 설계: 할인 정책 시스템 구현
    
이번 과제의 핵심 목표는 **변화에 유연한 실무형 아키텍처**를 구축하는 것이었습니다. 특히 비즈니스 요구사항에 따라 수시로 변하는 할인 정책을 안정적으로 수용하기 위해 다음과 같은 설계 원칙을 고민하고 적용했습니다.

<br>
<br>

---

# 기본 요구사항 🎯
과제의 기본 요구사항을 만족하는 과정에서 깊게 고민했던 과정을 담았습니다. 직관적이고 단순한 설계와 유연한 설계의 차이를 고민하면서 '왜 그렇게 했는가?'에 대한 근거를 명확히 설명하고자 하였습니다.

<br>

## DDD를 통한 응집도 향상
    
객체가 스스로 상태를 관리하고 로직을 수행하는 풍부한 도메인 모델을 지향했습니다. 특히 할인 정책 적용 로직을 서비스 계층에서 엔티티 내부로 응집시키는 과정에서 다음과 같은 설계적 고민을 거쳤습니다.
  
### 1. 풍부한 도메인 모델 지향
    
**고민 지점**   
기존 서비스 계층(OrderService)이 할인 금액을 직접 계산하고 이를 주문 객체(Order)에 주입하는 방식은 서비스 계층을 비대하게 만들고, 객체는 단순히 데이터를 담는 용도로 사용되었습니다.

    
**객체지향적 판단**   
서비스 계층은 비즈니스 흐름을 제어하는 **'조율자'** 역할에 집중해야 합니다. 구체적인 할인 계산과 적용은 주문 객체의 책임이라 판단하여 해당 로직을 `Order` 엔티티 내부로 위임했습니다.

    
**변경 내용**   
OrderService는 다음과 같은 전체 흐름을 관리하며, 세부적인 행동은 객체에게 위임함으로써 **'Tell, Don't Ask'** 의 능동적 구조를 설계하였습니다.

```
AS-IS (절차지향): 회원 찾기 -> 정책 찾기 -> 등급 꺼내기 -> 가격 꺼내기 -> 할인 금액 계산하기 -> 주문에 넣기 -> 결제하기   
    
TO-BE (객체지향): 회원 찾기 -> 정책 찾기 -> 주문에 할인 정책 적용하기 -> 결제하기
```
    
이로 인해 OrderService는 전체 비즈니스 프로세스를 보다 간결하고 직관적으로 관리할 수 있게 되었습니다.

<br>
    
### 2. DIP를 통한 결합도 제어

**고민 지점**   
주문(Order)가 할인정책(Policy)을 알게 되면서 의존성 문제가 발생하진 않을까 우려했습니다.
    
**객체지향적 판단**   
객체 간의 상호작용 시 의존에 의해 문제가 되는 상황은 대개 A가 바뀌면 B도 같이 고쳐야 할 때라고 생각합니다. 이를 구체 클래스가 아닌 인터페이스에 의존(DIP)하도록 설계하여 결합도를 제어하고자 하였습니다.

**변경 내용**
```
AS-IS (강한 결합): Order가 VIPDiscountPolicy 등의 구체 클래스를 직접 의존. 정책이 변경되거나 추가될 때마다 Order 내부 코드 수정이 불가피함.

TO-BE (약한 결합): Order는 DiscountPolicy 인터페이스만 의존. 실제 어떤 정책이 들어오는지와 무관하게 Order는 일관된 행위를 수행하며, 정책 확장에 자유로움.
```

<br>
<br>

## 전략 패턴 적용과 OCP 실현

다양한 할인 정책을 동적으로 선택할 수 있는 구조를 확립했습니다.

**고민 지점**   
직관적인 `if-else` 또는 `switch` 문 대신 리스트 순환 구조의 `전략 패턴`을 선택한 할인정책 적용 방식을 통해 얻는 실익이 무엇인가 고민했습니다.

**객체지향적 판단**   
조건문은 새로운 정책이 추가될 때마다 기존 코드를 수정해야 하는 **OCP 위반**을 야기합니다. 대신, `DiscountPolicyProvider`가 정책 리스트를 순회하며 지원 여부(`isSupport`)를 묻고 반환하는 방식은 Provider가 정책확장의 영향을 받지 않습니다.

**변경 내용**
```
AS-IS (OCP 위반): 정책 추가 시 관리 클래스(`Provider`)를 열어 분기문을 추가해야 함. 사이드 이펙트 위험 존재.

TO-BE (OCP 실현): 새로운 정책 클래스를 '추가'하기만 하면, 기존 로직의 수정 없이 즉시 시스템에 반영되는 **플러그인 구조**를 완성함.
```

<br>
<br>
    
## TDD를 통한 안정적인 확장

설계 방법론으로 단순한 사후 검증이 아닌 TDD를 활용했습니다.

**설계 의도**   
테스트를 단순한 사후 검증이 아닌 설계 가이드로 활용했습니다. 구현보다 객체에 기대하는 행위를 먼저 정의하여, 객체가 비대해지는 것을 방지하고 최소한의 책임만 지도록 유도했습니다.

**구현 방식**   
서비스를 먼저 만들고 테스트를 맞추는 것이 아니라, 원하는 입력과 결과를 먼저 명세화한 뒤 이를 충족하는 최소한의 코드를 구현했습니다.

**성과**   
핵심 도메인의 로직을 사전에 완벽히 검증함으로써 안정적인 확장이 가능해졌으며, 테스트 코드 자체가 시스템의 명세서가 되어 리팩토링 시 안정성을 확보할 수 있었습니다.

<br>
<br>

## 예외처리

**VVIP 혜택 역전 방지**   
정률 할인(10%) 적용 시, 저가 상품에서 VVIP가 VIP(고정 1,000원 할인)보다 적은 혜택을 받는 '역전 현상'을 방지하도록 구현하였습니다.

**마이너스 결제 차단**   
고정 할인액이 상품 가격보다 클 경우 발생할 수 있는 '마이너스 결제' 혹은 '결제 금액 0원 미만' 오류를 방지하고자 할인액이 원가를 초과하지 않도록 방어적으로 설계하여 비즈니스 무결성을 확보했습니다.

**결제 이력 무결성 확보**   
고객의 등급은 언제든 변할 수 있으므로, 추후 정산이나 CS 발생 시 결제 시점의 등급을 정확히 파악할 수 있도록 `Payment` 엔티티에 결제 당시의 `Grade`를 별도 필드로 저장하여, 데이터의 이력과 무결성을 확보했습니다.

<br>
<br>

## 추가적인 고려사항

- JPA의 `default_batch_fetch_size` 설정을 적용해 N+1 문제를 방지했습니다.
- DTO 성격의 객체는 record 타입을 사용해 보일러플레이트를 줄이고 불변성을 보장했습니다.
- 컨트롤러 버전관리 전략(/api/v1/…)을 통해 실무적 관점에서 서비스 운영의 안정성을 고려했습니다.

<br>
<br>
<br>

---

# 심화 요구사항 ⭐
보다 복잡한 요구사항을 만족하는 과정에서 겪은 어려움과 문제해결을 위한 사고과정을 담았습니다. 기존 코드를 유지하려 애쓰지 않고, 현재 마주한 어려움일지라도 다음엔 유연하게 대응할 수 있는 코드를 작성하려 노력했습니다.

<br>

## 할인 정책의 동적 변경
### 1. 문제 상황: 빈번한 정책 변경과 코드 수정의 결합   
현재 구조에서는 할인율이나 할인 금액을 변경할 때마다 서비스 내부 코드를 직접 수정하고 재배포해야 하는 번거로움이 있었습니다. 이를 해결하기 위해 할인 설정값(`DiscountSettings`)을 DB에서 관리하는 동적 설정 방식을 도입하고자 했으며, 그 과정에서 다음과 같은 설계적 고민을 마주했습니다.


### 2. 해결을 위한 시도와 기술적 제약   

**DiscountPolicy 구현체가 Repository를 직접 의존한다면?**   
- 가장 먼저 떠올린 방법은 정책 클래스가 직접 DB에서 설정값을 조회하는 것이었습니다. 하지만 현재 구조는 `Order` 엔티티 내부의 `applyDiscounts()` 메서드를 통해 할인을 적용합니다. 만약 정책 클래스가 Repository를 의존하게 되면, 결과적으로 Domain Entity가 Repository를 의존하게 되는 부적절한 계층 구조가 형성됩니다. 이는 엔티티의 순수성을 해치고 테스트 격리를 어렵게 만듭니다.   

<br>

**정책 객체(Singletons)에 설정값을 필드로 저장한다면?**   
- `DiscountPolicy`와 그 구현체들은 스프링 컨테이너에 의해 싱글톤 빈으로 관리됩니다. 만약 각 정책 객체가 상태(할인율 등)를 가지게 된다면, 멀티스레드 환경에서 **동시성 문제**가 발생할 위험이 큽니다.

<br>

**스프링 컨테이너 외부에서 객체를 직접 생성한다면?**   
- 빈 등록을 포기하고 매번 객체를 생성한다면 상태 문제는 해결되지만, `DiscountPolicyProvider`가 가진 `List<DiscountPolicy>`에 새로운 정책이 추가될 때마다 수동으로 주입해줘야 합니다. 이는 전략 패턴의 장점인 확장성을 활용하지 못하게 합니다.

<br>

**Context 객체에 설정값을 담아 전달한다면?**   
- 할인 결정에 필요한 데이터를 `Context`에 모두 담아 메서드 파라미터로 넘기는 방식입니다. 하지만 정책마다 필요한 설정값이 다르고, 한 번 조회한 데이터를 계속 들고 다녀야 하므로 코드가 지저분해지는 단점이 있었습니다.

### 3. Wrapper 객체(AppliedDiscountPolicy)의 도입

위의 모든 제약 사항을 해결하기 위해, 행위(Policy)와 상태(Setting)를 결합한 `AppliedDiscountPolicy`라는 래퍼 객체를 도입했습니다.

- **역할의 분리**: `DiscountPolicy`는 "할인 대상인가?"라는 로직만 담당하고, `DiscountSetting`은 DB에서 관리되는 상태(State)만 담당합니다.
- **동적 결합**: `DiscountPolicyProvider`가 런타임에 이 둘을 조회하여 `AppliedDiscountPolicy`로 묶어줍니다.
- **불변성과 안전성**: 생성된 래퍼 객체는 해당 주문 건에서만 유효한 불변 객체로 사용되므로 서비스의 안정성을 높입니다.

<br>
<br>

## 스냅샷 방식의 결제 이력 관리

할인 정책(`DiscountSetting`)은 비즈니스 상황에 따라 언제든 변할 수 있지만, 이미 완료된 주문 정보는 결제 시점의 상태를 그대로 유지해야 합니다.

### 1. 참조(Reference)가 아닌 복사(Snapshot) 전략
일반적인 외래키 참조 방식을 사용하면 원본 정책이 수정·삭제될 때 과거 주문 데이터까지 왜곡될 위험이 있습니다. 이를 방지하기 위해 결제 시점의 정책 이름, 할인율, 할인 금액 등을 컬럼 단위로 복사하여 저장했습니다. 덕분에 원본 데이터의 변화와 무관하게 결제 영수증의 무결성을 완벽히 보존할 수 있습니다.

### 2. `DiscountHistory`를 통한 명확한 근거 기록
주문 시점에 적용된 할인 정책의 상세 내역을 별도의 이력 테이블에 기록합니다. 이를 통해 당시 어떤 정책으로 얼마가 할인되었는지에 대한 명확한 검증이 가능합니다.

### 3. 검증된 데이터 신뢰성
`DiscountIntegrateTest`를 통해 정책이 업데이트되거나 삭제되는 시나리오에서도 기존 이력 데이터는 영향받지 않고 초기 상태를 유지함을 코드로 증명하여 시스템의 신뢰도를 확보했습니다.

<br>
<br>

## `DiscountContext`를 활용한 확장에 유연한 설계

기존 설계에서 포인트 결제 할인을 추가할 때, `isSupport()` 메서드의 파라미터를 직접 수정해야 하는 문제가 있었습니다. 이는 인터페이스의 규격이 변함에 따라 모든 구현체를 수정해야 하는 문제로 이어졌고, 향후 새로운 할인 기준이 생길 때마다 같은 문제가 반복될 것이라 판단했습니다.

### 1. 인터페이스 파손 방지 및 OCP 준수
할인 기준이 되는 정보를 개별 파라미터가 아닌 `DiscountContext` 객체로 캡슐화했습니다. 이제 새로운 할인 기준이 추가되더라도 `DiscountContext` 내부 필드만 확장하면 되도록 구현함으로써 OCP를 준수하였습니다.

### 2. 변화에 유연한 다중 조건 대응
`DiscountContext`를 통해 모든 할인 기준 정보를 한 번에 넘겨줌으로써, 각 정책 구현체는 자신에게 필요한 정보만 선택적으로 사용하여 지원 여부를 판단할 수 있게 되었습니다.

<br>
<br>

## Fixture 도입을 통한 테스트 코드의 유지보수성 향상

잦은 리팩토링 과정에서 객체의 생성 방식이 변경될 때마다, 연관된 수많은 테스트 코드를 일일이 수정해야 하는 문제가 있었습니다. 리팩토링시 테스트 코드의 안정성을 확보하기 위해 Fixture 패턴을 도입했습니다.

### 1. 객체 생성 로직의 캡슐화
테스트에 필요한 객체 생성 로직을 `MemberFixture` 등 별도의 클래스로 전용화했습니다. 결과적으로 객체의 구조가 바뀌더라도 Fixture 클래스 한 곳만 수정하면 모든 테스트 케이스에 반영됩니다.

### 2. 테스트 의도의 명확화
Fixture를 활용하면 테스트에 불필요한 설정값(ID, 이름 등)을 숨기고, 실제 검증에 필요한 데이터만 파라미터로 넘길 수 있습니다. 덕분에 테스트 코드가 훨씬 간결해지고, 어떤 시나리오를 검증하려는지 그 의도가 명확히 드러나는 효과를 얻었습니다.

### 3. 리팩토링 내성 강화
객체 생성 방식이 변경되어도 기존 테스트 로직 자체는 흔들리지 않는 리팩토링 내성을 갖추게 되었습니다.
